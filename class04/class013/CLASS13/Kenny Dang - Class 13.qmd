---
title: "CLASS13"
author: "Kenny Dang (PID: A18544481)"
format: pdf
---

```{r}
library(DESeq2)
```


## Background

Today we will perform an RNASeq analysis on the effects of dexomethiosome (hereafter "dex"), a common steroid, on airway smooth muscle (ASM) cell lines.

## Data Import 

We need two things for this analysis:

- **countData**: a table with genes as rows and samples/experiments as columns.
- **colData**: metadata about the columns (ex. samples) in the mean countData object


```{r import}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <- read.csv("airway_metadata.csv")
```


Let's have a wee peak at these two objects:

```{r}
head(counts)
```


```{r}
head(metadata)
```

## Check on metadata counts correspondance

We need to check that the metadata matches the samples in our count data. 

```{r}
ncol(counts) == nrow(metadata)
```


```{r}
colnames(counts) == metadata$id

```

```{r}
all(c(T,T,F,T))
```


> Q1. How many genes are in this dataset?

There are 38694 genes in the dataset.

```{r}
nrow(counts)
```



> Q2. How many 'control' cell lines do we have?

There are four 'control' cell lines.  

```{r}
sum (metadata$dex == "control")
```


## Analysis Plan...

We have four replicates per condition ("control" and "treated")
We want to compare the control vs. the treated to see which genes expression levels change when we have the drug present. We will see if a number changes when a drug is present. In other words: "we will go row by row (gene by gene) and see if the average value in control columns is different than the average value in treated columns"

- Step 1. Find which columns in `counts` correspond to "control" samples.

- Step 2. Extract/select these columns 

- Step 3. Calculate an average value for each gene (i.e. each row).

```{r}
# The indices (i.e positions) that are "control"
control.inds <- metadata$dex == "control"
```


```{r}
#Extract/select these "control" columns from counts
control.counts <- counts[, control.inds]
```


```{r}
# Calculate the mean for each gene (i.e row)
control.mean <- rowMeans(control.counts)
control.mean
```

> Q. Do the same for the "treated" samples - find the mean count value per gene

```{r}
control.inds1 <- metadata$dex == "treated"
```

```{r}
treated.counts <- counts[, control.inds1]
```

```{r}
treated.mean <- rowMeans(treated.counts)
treated.mean
```



> Q3. How would you make the above code in either approach more robust? Is there a function that could help here?

The function can be made more robust by using the rowSums() function.

> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
control.inds1 <- metadata$dex == "treated"
```

```{r}
treated.counts <- counts[, control.inds1]
```

```{r}
treated.mean <- rowMeans(treated.counts)
treated.mean
```


Let's put these two mean values into a new data.frame `meancounts` for easy book-keeping and plotting. 

```{r}
meancounts <- data.frame (control.mean, treated.mean)
meancounts
```

```{r}
colSums(meancounts)
```

> Q. Make a ggplot of average counts of control vs. treated

```{r}
library (ggplot2)

 ggplot(meancounts) + aes(x= control.mean, y = treated.mean) + geom_point(alpha = 0.3) + scale_x_log10() + scale_y_log10()
```

This is screeming to be log transformed as it is so highly skewed. 



> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. 

```{r}
plot(meancounts[,1],meancounts[,2], xlab="Control", ylab="Treated")
```



> Q5. (b). You could use the ggplot2 package to make this figure producing the plot below. What geom_?() function would use use for this plot?

I would use the "geom_point()" function for this plot. 


```{r}
library (ggplot2)

ggplot(meancounts) + aes(control.mean, treated.mean) + geom_point(alpha = 0.3)
```





> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this? 

I used the functions "scale_x_log10()" and "scale_y_log10()" to produce the plots below.  

```{r}
library (ggplot2)

ggplot(meancounts) + aes(x= control.mean, y = treated.mean) + geom_point(alpha = 0.3) + scale_x_log10() + scale_y_log10() + labs (x = "log Control", y = "log Treated")
```



```{r}
library (ggplot2)

ggplot(meancounts) + aes(x= control.mean, y = treated.mean) + geom_point(alpha = 0.3) + scale_x_log10() + scale_y_log10() + labs (x = "log Control", y = "log Treated") + scale_x_continuous(trans="log2") + scale_y_continuous(trans="log2")
```
## Log2 units and fold change

If we consider "treated"/"control" counts we will get a number that tells us the change.

```{r}
# No change
log2(20/20)
```



```{r}
# A doubling in the treated vs control. 
log2(40/20)
```

```{r}
log2(10/20)
```







> Q. Add a new column `log2fc` for log2 fold change of treated/control to our `meancounts` object

```{r}
meancounts$log2fc <- log2(meancounts$treated.mean/meancounts$control.mean)

head(meancounts)
```


## Remove zero count: genes

Typically we would not consider zero count genes - as we have no data about them and they should be excluded from further consideration. These lead to "funky" log2 fold change values (e.g. divide by zero errors etc.)

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique () function? 

The arr.ind argument provides the row/column positions instead of linear indices and these have TRUE values. We take the first column to get the row numbers and we want to remove the rows that contain zeros in either control or treated. We use the "unique()" function so that each row is removed only once and so in other words, each row index appears only once and we do not want to count a row twice.

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```


```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```


> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level?

There are 250 upregulated genes that are greater than 2 fc level. 
Up: 250

```{r}
sum(up.ind, na.rm = TRUE)
```


> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level?

There are 367 down regulated genes that we have that are greater than 2 fc level. 
Down: 367


```{r}
sum(down.ind, na.rm = TRUE)

```

> Q10. Do you trust these results? Why or why not? 

No, because these results are misleading due to our analysis being done based on fold change. Our results show how big the change is, but not whether or not that change is statistically reliable/significant (based on p-values). A gene could have very low counts or high variability between replicates and still have a big fold change. We have not calculated p-values or adjusted for multiple testing and so these results may have many false positives. 


```{r, message = FALSE}
library(DESeq2)
```

```{r}
library(DESeq2)
citation("DESeq2")
```


```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
dds
```
## Principal Component Analysis (PCA)

```{r}
library (DESeq2)

vsd <- vst (dds, blind = FALSE)
plotPCA(vsd, intgroup = c("dex"))
```


```{r}
pcaData <- plotPCA(vsd, intgroup=c("dex"), returnData=TRUE)
head(pcaData)
```

```{r}
# Calculate percent variance per PC for the plot axis labels
percentVar <- round(100 * attr(pcaData, "percentVar"))
percentVar
```



```{r}
ggplot(pcaData) +
  aes(x = PC1, y = PC2, color = dex) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() +
  theme_bw()
```

## DESeq analysis

We are missing any measure of significance from the work we have so far. Let's do this properly with the **DESeq2** package. 


The DESeq2 package, like many bioconductor packages, wants it's input in a very specific way - a data structure setup with all the info it needs for the calculation.


The main function in this package is called `DESeq()` it will run the full analysis for us on our `dds` input object:



```{r}
dds1 <- DESeq(dds)

```



Extract our results:

```{r}
res <- results(dds1)
head(res)
```

```{r}
summary(res)
```

```{r}
res05 <- results(dds1, alpha=0.05)
summary(res05)
```

## Adding annotation data


```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```


```{r}
columns(org.Hs.eg.db)
```


```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), 
                     keytype="ENSEMBL",        
                     column="SYMBOL",         
                     multiVals="first")
```


```{r}
head(res)
```


> Q11. Run the madIds() function two more times to add the Entrez ID and UniProt acession and GENENAME as new columns called res$entrez, res$uniport and res$genename.


```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="UNIPROT",
                     keytype="ENSEMBL",
                     multiVals="first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="GENENAME",
                     keytype="ENSEMBL",
                     multiVals="first")

head(res)
```


```{r}
ord <- order( res$padj )
#View(res[ord,])
head(res[ord,])
```

```{r}
write.csv(res[ord,], "deseq_results.csv")
```


## Volcano Plot

A useful summary figure of our results is often called a volcano plot. It is basically a plot of log2 fold change values vs. Adjusted P-values. 

> Q. Use ggplot to make a first version "volcano plot" of `log2FoldChange` vs `padj`

This is not very useful because the y-axis (P-value) is not really helpful - we want to focus on low P-values.  
```{r}
library(ggplot2)

ggplot(res) + aes(x = log2FoldChange, y = (padj)) +
  geom_point() +
  xlab("Log2 Fold Change") +
  ylab("-Log10 p-value") +
  ggtitle("Volcano Plot")

```




```{r}
library(ggplot2)

ggplot(res) + aes(x = log2FoldChange, y = log(padj)) +
  geom_point() +
  xlab("Log2 Fold Change") +
  ylab("-Log10 p-value") +
  ggtitle("Volcano Plot")

```

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
      xlab="Log2(FoldChange)",
      ylab="-Log(P-value)")
```




```{r}
library(ggplot2)

ggplot(res) + aes(x = log2FoldChange, y = -log(padj)) +
  geom_point() +
  xlab("Log2 Fold Change") +
  ylab("-Log10 p-value") +
  ggtitle("Volcano Plot") +
  geom_vline(xintercept = c(-2, +2), col= "red") +
  geom_hline(yintercept = -log(0.05), col="red")

```

Anything on the right means upregulate, expression level going up. The outliers means the difference is significant.

```{r}
library(EnhancedVolcano)

x <- as.data.frame(res)

EnhancedVolcano(x,
    lab = x$symbol,
    x = 'log2FoldChange',
    y = 'pvalue')
```



## Add some plot annotation

> Q. Add color to the points (genes) we care about, nice axis labels, a useful title and a nice theme.



library(ggplot2)

ggplot(res) + aes(x = log2FoldChange, y = -log(padj)) +
  geom_point(mycols <- "gray") +
  xlab("Log2 Fold Change") +
  ylab("-Log10 p-value") +
  ggtitle("Volcano Plot") +
  geom_vline(xintercept = c(-2, +2), col= "red") +
  geom_hline(yintercept = -log(0.05), col="red")
  
  mycols[res$log2FoldChange) > 2 ]  <- "blue"
  mycols[res$log2FoldChange) < -2 ]  <- "darkgreen"
  mycols[res$padj >= 0.05] <- "gray"


```{r}
# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```


## Save our results to a CSV file 

```{r}
write.csv(res, file="results.csv")
```


```{r}
-log(0.005)
```

